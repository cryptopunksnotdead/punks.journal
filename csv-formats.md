
# Why the CSV standard library is broken, broken, broken (and how to fix it), Part II or The Wonders of CSV Formats / Dialects


What's broken (and wrong, wrong, wrong) with the CSV standard library? Let's count the ways. 

**[Start with Part I in the series » ](why-the-csv-stdlib-is-broken.md)**





> I disagree that it's broken. It's implementing the [strict] RFC [4180 CSV format]
> and gives you the tools that allow you to be less strict.   

No, it doesn't. Let's say you want to read in a CSV datafile exported by MySQL or by PostgreSQL.
Note: The MySQL and PostgreSQL CSV formats are as strict as your "standard"
RFC4180 format BUT using different (strict) rules for escapes or null values.
Here be dragons. With the no batteries included CSV standard library
you're on your own.
Let's have a look.



## MySQL CSV Format / Dialect

Let's start with the MySQL CSV export format / dialect.
The MYSQL docu reads:

> If you specify no FIELDS or LINES clause,
> the defaults are the same as if you had written this:
>
>     FIELDS TERMINATED BY '\t'
>     ENCLOSED BY ''
>     ESCAPED BY '\\'
>     LINES TERMINATED BY '\n'
>     STARTING BY ''
>
> (Backslash is the MySQL escape character within strings in SQL statements,
> so to specify a literal backslash, you must specify two backslashes for the value to be interpreted as a single backslash.
> The escape sequences '\t' and '\n' specify tab and newline characters, respectively.)

In practice that looks like:

```
1→a string→100.20
2→a string containing a , comma→102.20
3→a string containing a " quote→102.20
4→a string containing a ", quote and comma→102.20
```

Note: Values are separated by tabs (`\t`)
and NEVER enclosed in (double) quotes (`"`).

Edge cases:
- Q: How can you use tabs in your values?
- Q: How can you use newlines in your values?
- Q: How can you know that a value is nil / null and not an empty string?


A: Tabs and newlines get escaped (unix-style) with backslash (`\n` or `\t`)
and the mysql convention for nil / null is using a "custom" escape, that is,
(`\N`). Note, the uppercase N in (`\N`).

<!--
Todo: check if mysql escapes by default tabs and newlines?
check if mysql uses \n by default?
-->

Now any volunteers for reading this MySQL CSV format with the
CSV standard library? Sorry, it doesn't support unix-style escapes
and, sorry, it doesn't know anything about null values either.


Using the "new" csv reader library it's all pre-configured
and built-in and, thus, as easy as:

``` ruby
records = Csv.mysql.read( "values.csv" )
```

As a bonus exercise lets
change the separator to comma (`,`).
Note: Mysql does NOT support doublequote (that is, doubling of double quotes
for escaping double quotes in double quotes)
but uses "unix-style" escaping with backslash (`\`). Example:


```
FIELDS TERMINATED BY ','
ENCLOSED BY '"'
ESCAPED BY '\\'
LINES TERMINATED BY '\n'
```

results in:

```
1,"a string",100.20
2,"a string containing a , comma",102.20
3,"a string containing a \" quote",102.20
4,"a string containing a \", quote and comma",102.20
```

Using the "new" csv reader library
with a changed "custom" mysql configuration is
as easy as:

``` ruby
Csv.mysql.sep   = ','     # note: was "\t"
Csv.mysql.quote = '"'     # note: was nil

records = Csv.mysql.read( "values.csv" )
```

Note: The CSV standard library has no concept or option
for turning on/off doubling of double quotes
for escaping double quotes in double quotes (`doublequote=true/false`)
or for turning on/off unix-style escapes with backslash (`escape='\'`).
Here be dragons. You're on your own again.




## PostgreSQL CSV Formats / Dialects

Let's continue with the PostgreSQL CSV export formats / dialects.
Yes, PostgreSQL has two "standard" default export formats
called TEXT and CSV.


### PostgreSQL TEXT

Let's start with PostgreSQL TEXT. The PostgreSQL docu reads:

> When the text format is used, the data written is a text file with one line per table row.
> Columns in a row are separated by the delimiter character.
> The column values themselves are strings generated by the output function
> of each attribute's data type. The specified null string is used in place of columns that are null.
> 
> Backslash characters (`\`)
> can be used in the COPY data to quote data characters that might otherwise be taken as
> row or column delimiters. In particular, the following characters must be preceded by a backslash
> if they appear as part of a column value:
> backslash itself, newline, carriage return, and the current delimiter character.
>
> The specified null string is sent by COPY TO without adding any backslashes.
> Therefore, a null string such as `\N` cannot be confused with the actual data value `\N`
> (which would be represented as `\\N`).


In practice that looks like
the mysql default format above with:

<!--
todo: add csv example here!!!
-->

- The default separator is tab (`sep = "\t"`),
- newlines and tabs in values get escaped unix-style with backslash (`escape = '\'`) and
- null values get "custom" escaped with `\N`.


Using the "new" csv reader library it's all pre-configured
and built-in and, thus, as easy as:

``` ruby
records = Csv.postgresql_text.read( "values.csv" )
```


### PostgreSQL CSV

Now lets continue with the "proper" PostgreSQL CSV export format.
The docu reads:

> This format option is used for exporting the Comma Separated Value (CSV) file format used by many other programs,
> such as spreadsheets. Instead of the escaping rules used by PostgreSQL's standard text format,
> it produces the common CSV escaping mechanism.
>
> The values in each record are separated by the DELIMITER character.
> If the value contains the delimiter character, the QUOTE character, the NULL string, a carriage return, or line feed character,
> then the whole value is prefixed and suffixed by the QUOTE character,
> and any occurrence within the value of a QUOTE character or the ESCAPE character is preceded by the escape character.
> You can also use FORCE_QUOTE to force quotes when outputting non-NULL values in specific columns.
>
> The CSV format has no standard way to distinguish a NULL value from an empty string.
> PostgreSQL's COPY handles this by quoting.
> A NULL is output as the NULL parameter string and is not quoted,
> while a non-NULL value matching the NULL parameter string is quoted.
> For example, with the default settings, a NULL is written as an unquoted empty string,
> while an empty string data value is written with double quotes ("").



The good news - using the "new" csv reader library it's all pre-configured
and built-in and, thus, as easy as:

``` ruby
records = Csv.postgresql.read( "values.csv" )
```


Now any volunteers for reading this PostgreSQL CSV format with the
CSV standard library? Here be dragons. You're on your own again :-).


## Request for Comments (RFC)

Please post ycomments to the [ruby-talk mailing list](https://rubytalk.org) thread. Thanks!

Any other CSV format you want to see pre-configured and supported "out-of-the-box"? Please tell.
